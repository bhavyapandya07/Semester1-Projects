# -*- coding: utf-8 -*-
"""Untitled24.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/190-lq7_FNtC6BrZCV4xSjvho6I53rTXU
"""

import numpy as np
import random
import math
import matplotlib.pyplot as plt
import time

# -------------------------
# TSP Setup
# -------------------------
n_cities = 12  # Increase number of cities for meaningful comparison
cities = np.random.randint(0, 50, size=(n_cities, 2))

def distance_matrix(cities):
    n = len(cities)
    dist = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            dist[i, j] = np.linalg.norm(cities[i]-cities[j])
    return dist

dist_matrix = distance_matrix(cities)

def total_distance(path, dist_matrix):
    return sum(dist_matrix[path[i-1], path[i]] for i in range(len(path)))

# -------------------------
# 1Ô∏è Simulated Annealing
# -------------------------
def simulated_annealing(dist_matrix, temp=1000, alpha=0.995, iterations=1000):
    n = len(dist_matrix)
    current_path = list(range(n))
    random.shuffle(current_path)
    best_path = current_path[:]
    best_dist = total_distance(best_path, dist_matrix)
    convergence = []

    for i in range(iterations):
        a, b = random.sample(range(n), 2)
        new_path = current_path[:]
        new_path[a:b] = reversed(new_path[a:b])
        new_dist = total_distance(new_path, dist_matrix)
        if new_dist < best_dist or random.random() < math.exp((best_dist - new_dist) / temp):
            current_path = new_path
            if new_dist < best_dist:
                best_path = new_path
                best_dist = new_dist
        temp *= alpha
        convergence.append(best_dist)

    return best_path, best_dist, convergence

# -------------------------
#  2 Genetic Algorithm
# -------------------------
def genetic_algorithm(dist_matrix, pop_size=20, generations=100, mutation_rate=0.2):
    n = len(dist_matrix)
    population = [random.sample(range(n), n) for _ in range(pop_size)]
    convergence = []

    def fitness(path):
        return 1 / total_distance(path, dist_matrix)

    for _ in range(generations):
        population = sorted(population, key=lambda p: fitness(p), reverse=True)
        new_population = population[:2]  # Elitism
        while len(new_population) < pop_size:
            parents = random.sample(population[:5], 2)
            cut = random.randint(1, n-2)
            child = parents[0][:cut] + [c for c in parents[1] if c not in parents[0][:cut]]
            if random.random() < mutation_rate:
                a, b = random.sample(range(n), 2)
                child[a], child[b] = child[b], child[a]
            new_population.append(child)
        population = new_population
        best_dist = total_distance(population[0], dist_matrix)
        convergence.append(best_dist)

    best_path = population[0]
    best_dist = total_distance(best_path, dist_matrix)
    return best_path, best_dist, convergence


# -------------------------
# Run All Algorithms with timing
# -------------------------
start = time.time()
sa_path, sa_dist, sa_conv = simulated_annealing(dist_matrix)
sa_time = time.time() - start

start = time.time()
ga_path, ga_dist, ga_conv = genetic_algorithm(dist_matrix)
ga_time = time.time() - start

print("========== Results ==========\n")
print(f"Simulated Annealing Path:\n {sa_path}\n Distance: {sa_dist:.2f}\n Time: {sa_time:.6f} secconds\n")
print("========== Results ==========\n")
print(f"Genetic Algorithm Path:\n {ga_path}\n Distance: {ga_dist:.2f}\n Time: {ga_time:.6f} seconds\n")

# -------------------------
# Plot Paths
# -------------------------
def plot_path(cities, path, title):
    path = list(map(int, path))
    path_coords = cities[path + [path[0]]]
    plt.plot(path_coords[:,0], path_coords[:,1], 'o-', label=title)
    for i, (x, y) in enumerate(cities):
        plt.text(x, y, str(i))
    plt.title(title)
    plt.show()

plot_path(cities, sa_path, "Simulated Annealing Path")
plot_path(cities, ga_path, "Genetic Algorithm Path")

# -------------------------
# Plot Convergence
# -------------------------
plt.plot(sa_conv, label="SA")
plt.plot(ga_conv, label="GA")
plt.xlabel("Iteration")
plt.ylabel("Best Distance")
plt.title("Convergence Comparison")
plt.legend()
plt.show()